
// @ts-nocheck
import { PixelGridData, YarnColor, CellData } from '../types';

// Configuration for PDF layout
const PDF_CONFIG = {
    pageSize: 'a4',
    orientation: 'portrait',
    margin: 30,
    headerHeight: 40,
    minCellSize: 18, 
    fontSize: {
        title: 24,
        header: 14,
        cell: 7,
        legend: 10,
        ruler: 8
    }
};

const getTextColor = (hex: string): string => {
    if (!hex) return '#000000';
    const rgb = parseInt(hex.slice(1), 16);
    const r = (rgb >> 16) & 0xff;
    const g = (rgb >> 8) & 0xff;
    const b = (rgb >> 0) & 0xff;
    const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    return luma < 128 ? '#FFFFFF' : '#000000';
};

const generateNumberingData = (grid: CellData[], width: number, height: number, isLeftHanded: boolean): string[] => {
    const numbers = Array(width * height).fill('');
    for (let y = 0; y < height; y++) {
        let count = 0;
        let currentColor = null;

        // Numbering Direction Logic:
        // Standard (Right-Handed):
        //   Row 1 (Odd): Left -> Right (indices increase) [User Spec: "Odd numbers on Left"]
        //   Row 2 (Even): Right -> Left (indices decrease) [User Spec: "Even numbers on Right"]
        
        // Left-Handed (Mirrored):
        //   Row 1 (Odd): Right -> Left (indices decrease)
        //   Row 2 (Even): Left -> Right (indices increase)

        const rowNumber = y + 1;
        const isOddRow = rowNumber % 2 !== 0;
        
        // Determine if we should reverse the x-coordinates (count Right-to-Left)
        // Default: Even rows reverse.
        // Left-Handed: Odd rows reverse.
        const shouldReverse = isLeftHanded ? isOddRow : !isOddRow;

        const xCoordinates = Array.from({ length: width }, (_, i) => i);
        if (shouldReverse) {
            xCoordinates.reverse();
        }

        for (const x of xCoordinates) {
            const index = y * width + x;
            const cellColor = grid[index].colorId;

            if (cellColor === null) {
                count = 0;
                currentColor = null;
                continue;
            }

            if (cellColor === currentColor) {
                count++;
            } else {
                count = 1;
                currentColor = cellColor;
            }
            numbers[index] = String(count);
        }
    }
    return numbers;
};

export const exportPixelGridToPDF = (
    projectName: string,
    gridData: PixelGridData,
    yarnPalette: YarnColor[],
    yarnUsage: Map<string, number>,
    options: { forceSinglePage?: boolean } = {},
    projectSettings: any = {},
    isLeftHanded: boolean = false
) => {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'a4',
  });

  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();
  const margin = PDF_CONFIG.margin;
  
  const yarnColorMap = new Map(yarnPalette.map(yc => [yc.id, yc]));
  const numbering = generateNumberingData(gridData.grid, gridData.width, gridData.height, isLeftHanded);

  // --- STEP 1: CALCULATE LAYOUT ---
  const availableW = pageW - margin * 2;
  const availableH = pageH - margin * 2 - 60; 

  const singlePageCellW = (availableW - 40) / gridData.width; 
  const singlePageCellH = (availableH - 40) / gridData.height;
  const singlePageCellSize = Math.min(singlePageCellW, singlePageCellH);

  let pagesX = 1;
  let pagesY = 1;
  let cellSize = singlePageCellSize;

  if (singlePageCellSize < PDF_CONFIG.minCellSize && !options.forceSinglePage) {
      cellSize = PDF_CONFIG.minCellSize;
      const cellsPerW = Math.floor((availableW - 40) / cellSize); 
      const cellsPerH = Math.floor((availableH - 40) / cellSize);
      
      pagesX = Math.ceil(gridData.width / cellsPerW);
      pagesY = Math.ceil(gridData.height / cellsPerH);
  }

  // --- STEP 2: GENERATE COVER PAGE ---
  doc.setFontSize(PDF_CONFIG.fontSize.title);
  doc.text(projectName, margin, margin + 20);
  
  doc.setFontSize(12);
  doc.text(`Dimensions: ${gridData.width} x ${gridData.height} stitches`, margin, margin + 50);
  doc.text(`Generated by BlanketSmith`, margin, margin + 65);
  if (options.forceSinglePage) {
       doc.setTextColor(100);
       doc.text("(Overview Mode)", margin + 200, margin + 20);
       doc.setTextColor(0);
  }
  if (isLeftHanded) {
      doc.setTextColor(100);
      doc.text("(Left-Handed Mode)", margin + 200, margin + 35);
      doc.setTextColor(0);
  }

  // Draw Yarn Legend
  let legendY = margin + 100;
  doc.setFontSize(14);
  doc.text("Yarn Requirements", margin, legendY);
  legendY += 20;

  const swatchSize = 15;
  doc.setFontSize(10);
  
  const sortedYarns = gridData.palette
    .sort((a,b) => (yarnUsage.get(b) || 0) - (yarnUsage.get(a) || 0));
    
  // Header for legend
  doc.setFont("helvetica", "bold");
  doc.text("Color", margin + 25, legendY);
  doc.text("Details", margin + 150, legendY);
  doc.text("Usage", margin + 350, legendY);
  doc.setFont("helvetica", "normal");
  legendY += 15;

  sortedYarns.forEach(yarnId => {
      const yarn = yarnColorMap.get(yarnId);
      const count = yarnUsage.get(yarnId) || 0;
      
      const yarnPerStitch = projectSettings?.yarnPerStitch || 1;
      const totalYards = Math.ceil((count * yarnPerStitch) / 36);
      const skeinsNeeded = Math.ceil(totalYards / (yarn?.skeinLength || 295));
      
      if (yarn) {
          if (legendY > pageH - margin) {
              doc.addPage();
              legendY = margin;
          }
          
          doc.setFillColor(yarn.hex);
          doc.setDrawColor(0);
          doc.rect(margin, legendY, swatchSize, swatchSize, 'FD');
          
          doc.text(`${yarn.name}`, margin + 25, legendY + 11);
          doc.setFontSize(8);
          doc.text(`${yarn.brand} | ${yarn.yarnWeight || 'DK'}`, margin + 150, legendY + 11);
          doc.setFontSize(10);
          doc.text(`${count} sts  |  ${totalYards} yds  |  ${skeinsNeeded} skein${skeinsNeeded !== 1 ? 's' : ''}`, margin + 350, legendY + 11);
          
          legendY += 25;
      }
  });
  
  // Mini Map for Multipage
  if (pagesX > 1 || pagesY > 1) {
      if (legendY + 150 < pageH) {
           const mapY = legendY + 40;
           doc.setFontSize(14);
           doc.text("Pattern Overview", margin, mapY - 10);
           
           const mapW = Math.min(300, pageW - margin*2);
           const mapScale = mapW / gridData.width;
           
           for (let y = 0; y < gridData.height; y++) {
               for (let x = 0; x < gridData.width; x++) {
                   const cell = gridData.grid[y * gridData.width + x];
                   if (cell.colorId) {
                       const c = yarnColorMap.get(cell.colorId);
                       if (c) {
                           doc.setFillColor(c.hex);
                           doc.rect(margin + x * mapScale, mapY + y * mapScale, mapScale, mapScale, 'F');
                       }
                   }
               }
           }
           
           // Grid Overlay
           doc.setDrawColor(0);
           doc.setLineWidth(1);
           const cellsPerW = Math.floor((availableW - 40) / cellSize);
           const cellsPerH = Math.floor((availableH - 40) / cellSize);
           
           for(let py = 0; py < pagesY; py++) {
               for(let px = 0; px < pagesX; px++) {
                   const sx = px * cellsPerW;
                   const sy = py * cellsPerH;
                   const w = Math.min(cellsPerW, gridData.width - sx);
                   const h = Math.min(cellsPerH, gridData.height - sy);
                   
                   doc.rect(margin + sx * mapScale, mapY + sy * mapScale, w * mapScale, h * mapScale, 'S');
                   
                   const pageNum = (py * pagesX) + px + 1;
                   doc.setFontSize(10);
                   doc.setTextColor('#FF0000');
                   doc.text(String(pageNum), margin + (sx + w/2) * mapScale, mapY + (sy + h/2) * mapScale, { align: 'center', baseline: 'middle' });
                   doc.setTextColor(0);
               }
           }
      }
  }

  // --- STEP 3: GENERATE PATTERN PAGES ---
  if (options.forceSinglePage) {
      doc.addPage();
  }

  const cellsPerW = options.forceSinglePage ? gridData.width : Math.floor((availableW - 40) / cellSize);
  const cellsPerH = options.forceSinglePage ? gridData.height : Math.floor((availableH - 40) / cellSize);

  for (let py = 0; py < pagesY; py++) {
      for (let px = 0; px < pagesX; px++) {
          if (!options.forceSinglePage) doc.addPage(); 
          
          const startX = px * cellsPerW;
          const startY = py * cellsPerH;
          const endX = Math.min(startX + cellsPerW, gridData.width);
          const endY = Math.min(startY + cellsPerH, gridData.height);
          
          const sliceW = endX - startX;
          const sliceH = endY - startY;
          
          const drawX = margin + 40; 
          const drawY = margin + 30; 
          
          doc.setFontSize(10);
          if (options.forceSinglePage) {
               doc.text(`Full Pattern Chart`, margin, margin);
          } else {
               doc.text(`Page ${((py * pagesX) + px + 1)} of ${pagesX * pagesY}`, margin, margin);
               doc.text(`Cols ${startX+1}-${endX} | Rows ${startY+1}-${endY}`, pageW - margin, margin, { align: 'right' });
          }

          doc.setFontSize(PDF_CONFIG.fontSize.ruler);
          const showRulers = cellSize > 5; 

          if (showRulers) {
              // Column Numbers (Top)
              for (let i = 0; i < sliceW; i++) {
                  const gridX = startX + i;
                  if (i % 5 === 0 || options.forceSinglePage) // Show more frequently
                    doc.text(String(gridX + 1), drawX + (i + 0.5) * cellSize, drawY - 5, { align: 'center' });
              }
              
              // Row Numbers (Sides)
              for (let i = 0; i < sliceH; i++) {
                  const gridY = startY + i;
                  const rowNum = gridY + 1;
                  const isOdd = rowNum % 2 !== 0;
                  
                  // Logic for Side Placement
                  // Default: Odd on Left, Even on Right
                  // Left-Handed: Odd on Right, Even on Left
                  
                  const showOnLeft = isLeftHanded ? !isOdd : isOdd;
                  
                  if (showOnLeft) {
                       doc.text(String(rowNum), drawX - 5, drawY + (i + 0.5) * cellSize, { align: 'right', baseline: 'middle' });
                  } else {
                       // Show on Right
                       // The right edge of the grid slice is at: drawX + (sliceW * cellSize)
                       doc.text(String(rowNum), drawX + (sliceW * cellSize) + 5, drawY + (i + 0.5) * cellSize, { align: 'left', baseline: 'middle' });
                  }
              }
          }

          doc.setLineWidth(0.5);
          doc.setDrawColor('#CCCCCC');

          const forceNumbers = options.forceSinglePage;
          const renderNumbers = cellSize >= 10 || forceNumbers;

          for (let y = 0; y < sliceH; y++) {
              for (let x = 0; x < sliceW; x++) {
                  const gridX = startX + x;
                  const gridY = startY + y;
                  const index = gridY * gridData.width + gridX;
                  const cell = gridData.grid[index];
                  
                  const cx = drawX + x * cellSize;
                  const cy = drawY + y * cellSize;
                  
                  doc.setFillColor(255, 255, 255);
                  if (cell.colorId) {
                      const c = yarnColorMap.get(cell.colorId);
                      if (c) doc.setFillColor(c.hex);
                  }
                  doc.rect(cx, cy, cellSize, cellSize, 'FD');
                  
                  if (renderNumbers && cell.colorId) {
                      const c = yarnColorMap.get(cell.colorId);
                      const textColor = c ? getTextColor(c.hex) : '#000000';
                      doc.setTextColor(textColor);
                      
                      const dynamicFontSize = forceNumbers ? Math.max(2, cellSize * 0.7) : cellSize * 0.6;
                      doc.setFontSize(dynamicFontSize);
                      
                      doc.text(
                          numbering[index], 
                          cx + cellSize/2, 
                          cy + cellSize/2, 
                          { align: 'center', baseline: 'middle' }
                      );
                  }
              }
          }
          doc.setTextColor(0);
      }
  }

  const fileName = options.forceSinglePage 
    ? `${projectName}_overview.pdf`
    : `${projectName}_chart.pdf`;
  doc.save(fileName);
};
